# Copyright 2016 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

if (current_cpu == "x86") {
  _yasm_flags = [
    "-felf32",
    "-m",
    "x86",
  ]
} else if (current_cpu == "x64") {
  _yasm_flags = [
    "-DPIC",
    "-felf64",
    "-m",
    "amd64",
  ]
}

template("yasm_assemble") {
  action_name = "${target_name}_action"
  source_set_name = target_name

  action_foreach(action_name) {
    # Only the source set can depend on this.
    visibility = [ ":$source_set_name" ]

    script = "//third_party/yasm/run_yasm.py"
    sources = invoker.sources

    if (defined(invoker.inputs)) {
      inputs = invoker.inputs
    }

    deps = []
    if (defined(invoker.deps)) {
      deps += invoker.deps
    }

    args = [ "yasm" ] + _yasm_flags
    if (defined(invoker.yasm_flags)) {
      args += invoker.yasm_flags
    }

    # User defined include dirs go first.
    if (defined(invoker.include_dirs)) {
      foreach(include, invoker.include_dirs) {
        args += [ "-I" + rebase_path(include, root_build_dir) ]
      }
    }

    # Default yasm include dirs. Make it match the native build (source root and
    # root generated code directory).
    # This goes to the end of include list.
    args += [
      "-I.",

      # Using "//." will produce a relative path "../.." which looks better than
      # "../../" which will result from using "//" as the base (although both
      # work). This is because rebase_path will terminate the result in a
      # slash if the input ends in a slash.
      "-I" + rebase_path("//.", root_build_dir),
      "-I" + rebase_path(root_gen_dir, root_build_dir),
    ]

    # Extra defines.
    if (defined(invoker.defines)) {
      foreach(def, invoker.defines) {
        args += [ "-D$def" ]
      }
    }

    # Output file.
    outputs = [
      "$target_out_dir/$source_set_name/{{source_name_part}}.o",
    ]
    args += [
      "-o",
      rebase_path(outputs[0], root_build_dir),
      "{{source}}",
    ]

    # The wrapper script run_yasm will write the depfile to the same name as
    # the output but with .d appended (like gcc will).
    depfile = outputs[0] + ".d"
  }

  # Gather the .o files into a linkable thing. This doesn't actually link
  # anything (a source set just compiles files to link later), but will pass
  # the object files generated by the action up the dependency chain.
  static_library(source_set_name) {
    if (defined(invoker.visibility)) {
      visibility = invoker.visibility
    }

    sources = get_target_outputs(":$action_name")

    deps = [
      ":$action_name",
    ]
  }
}
